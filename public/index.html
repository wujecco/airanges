<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Buble One</title>
  <style>
    body {
      margin: 0;
      background: #0d0f23;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #bubble-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    .bubble {
      position: absolute;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      text-align: center;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
      /* Allow pointer interaction so bubbles can be dragged */
      pointer-events: auto;
      user-select: none;
      cursor: grab;
    }
    /* Change cursor while actively dragging */
    .bubble.dragging {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <div id="bubble-container"></div>
  <script>
    /**
     * This script implements an interactive bubble field.
     *
     * Key changes from the original version:
     *  - The number of bubbles has been increased from the original but
     *    reduced from the previous version to around 150 for better
     *    readability and performance.
     *  - Bubbles spawn randomly across the screen (rather than in a tight
     *    cluster) and repel each other to settle into an even distribution.
     *  - Pairwise repulsion runs each frame to prevent overlaps and, in
     *    combination with random initial velocities, provides a gentle drift.
     *  - Mouse interaction is rewritten: bubbles no longer flee from the
     *    pointer; instead you can click and drag any bubble. Dragging applies
     *    a proportional force so the bubble chases your pointer with some
     *    inertia. While dragging, the bubble still repels others, pushing
     *    them aside naturally. Releasing a bubble dampens its velocity to
     *    avoid jittery oscillations.
     */

    const container = document.getElementById('bubble-container');
    const bubbles = [];
        // Number of bubbles to display. This value is replaced once we load
        // S&P 500 constituents from the server. Defaults to 100 if the
        // request fails.
        let numBubbles = 100;

        // Track the maximum absolute percent change across all stocks. This is
        // used to scale bubble sizes proportionally so that the largest
        // percentage change corresponds to the largest bubble. It will be
        // computed once stock data is loaded.
        let maxAbsChange = 1;

    // When stock data is loaded from the server, it will be stored here.
    let stockData = null;
    // Base strength of inter‑bubble repulsion. A modest value causes bubbles
    // to separate gently without an explosive "blow‑apart" effect.  When a
    // bubble is actively dragged the repulsion force is temporarily
    // multiplied (see dragRepulsionMultiplier below) so that the dragged
    // bubble can more effectively push others aside. This base value
    // deliberately matches the earlier behaviour so un‑dragged bubbles
    // settle calmly.
    // Base repulsion strength between bubbles. Increasing this value will
    // make bubbles push each other apart more strongly. We slightly
    // increase it compared to the previous tuning to help dragged
    // bubbles clear a path through the field.
    const repulsionStrength = 0.08;
    // How much stronger the repulsion should be when one of the two
    // interacting bubbles is currently being dragged. A larger value
    // makes the dragged bubble act like a bull in a china shop, clearing
    // a path through neighbouring bubbles. We increase this from 4 to 6
    // so that a dragged bubble more effectively pushes aside its
    // neighbours.
    const dragRepulsionMultiplier = 6;
    // Reduce the repulsion applied to a bubble that has just been released
    // from a drag. While the "releasedCooldown" counter is greater than
    // zero, the repulsion force affecting that bubble will be scaled by
    // this factor. Lower values further suppress jitter after releasing a
    // bubble. We decrease this from 0.5 to 0.2 to damp residual
    // oscillations.
    const releasedRepulsionFactor = 0.2;
    // Friction factor to slow down bubbles over time. Lower friction
    // (closer to 0) means more damping. Increasing friction (closer to
    // 1) means less damping. We reduce friction slightly from 0.98 to
    // 0.96 so that velocities decay faster after interactions and
    // dragging, which should reduce post‑drag shaking.
    const friction = 0.96;
    // Amount of random jitter added to each bubble's velocity every frame
    // to simulate gentle drift. Keeping this small ensures a gentle
    // wandering motion across the viewport.
    const jitter = 0.03;

    /**
     * Generate a random hue for bubble colouring.
     * @returns {number}
     */
    function randomHue() {
      return Math.floor(Math.random() * 360);
    }

    /**
     * Create a bubble DOM element and corresponding state object.
     * Initially position all bubbles near the centre of the viewport with a
     * small random offset so they will push apart under the repulsion force.
     * @returns {{el: HTMLElement, x: number, y: number, vx: number, vy: number, size: number}}
     */
    function createBubble(stock) {
      /*
       * Create a bubble DOM element and corresponding state. Each bubble
       * contains three separate pieces of information: an optional icon,
       * the ticker symbol and the percentage change. These pieces are
       * individually sized based on the overall diameter of the bubble.
       * When stock data is provided, the diameter is scaled relative
       * to the largest absolute percentage change among all stocks
       * (maxAbsChange). This ensures the largest movers occupy the
       * largest space on screen, with visibly smaller bubbles for
       * subtler moves. Positive values are styled green, negative
       * values red. When no stock data is available (fallback mode),
       * random sizes and colours are used.
       */
      let size;
      let changePercent = 0;
      let gradient;
      let borderColor;
      // Create DOM nodes for the icon, ticker and percentage. In fallback
      // mode only one line of text is used.
      let iconSpan = null;
      let tickerSpan = null;
      let pctSpan = null;
      if (stock && stock.ticker) {
        changePercent = stock.changePercent || 0;
        const absChange = Math.abs(changePercent);
        // Determine diameter using the global maxAbsChange. We use a
        // minimum and maximum to clamp extreme values. The ratio ensures
        // a meaningful difference between small and large movers.
        const minSize = 60;
        const maxSize = 380;
        const ratio = maxAbsChange > 0 ? absChange / maxAbsChange : 0;
        size = minSize + (maxSize - minSize) * ratio;
        // Format percentage string with sign and one decimal place.
        const pctStr =
          (changePercent > 0 ? '+' : changePercent < 0 ? '' : '') +
          (isFinite(changePercent) ? changePercent.toFixed(1) + '%' : '0.0%');
        // Choose colours based on sign. Use a radial gradient for
        // interior shading and set a solid border colour for the neon ring.
        if (changePercent >= 0) {
          gradient =
            'radial-gradient(circle at 40% 40%, hsla(130, 60%, 60%, 0.9) 0%, hsla(130, 60%, 30%, 0.7) 70%, hsla(130, 60%, 20%, 0.0) 90%)';
          borderColor = 'hsl(130, 80%, 55%)';
        } else {
          gradient =
            'radial-gradient(circle at 40% 40%, hsla(0, 70%, 60%, 0.9) 0%, hsla(0, 70%, 30%, 0.7) 70%, hsla(0, 70%, 20%, 0.0) 90%)';
          borderColor = 'hsl(0, 80%, 55%)';
        }
        // Create the icon span. We use the first letter of the ticker
        // capitalised. This sits at the top of the bubble. Its size is
        // relative to the diameter of the bubble. A small circular
        // background behind the letter enhances readability and echoes
        // the reference design, which uses company logos. Note: you can
        // replace this with actual icons if available via an API.
        iconSpan = document.createElement('div');
        const iconLetter = stock.ticker.charAt(0).toUpperCase();
        iconSpan.textContent = iconLetter;
        // The icon itself is drawn on a circular background; we set
        // explicit width and height so the background is round.
        const iconDiameter = size * 0.35;
        iconSpan.style.width = iconDiameter + 'px';
        iconSpan.style.height = iconDiameter + 'px';
        iconSpan.style.borderRadius = '50%';
        // Lighten the border colour for the icon background.
        const iconBgColor = changePercent >= 0 ? 'hsla(130, 60%, 55%, 0.9)' : 'hsla(0, 60%, 55%, 0.9)';
        iconSpan.style.background = iconBgColor;
        // Center the letter inside the icon.
        iconSpan.style.display = 'flex';
        iconSpan.style.alignItems = 'center';
        iconSpan.style.justifyContent = 'center';
        iconSpan.style.color = '#ffffff';
        iconSpan.style.fontWeight = 'bold';
        // Font size for the letter is a fraction of the icon diameter.
        iconSpan.style.fontSize = (iconDiameter * 0.5) + 'px';
        iconSpan.style.lineHeight = '1';
        // Create ticker and percentage spans. Use large font for the ticker
        // and a smaller font for the percentage. The sizes scale with
        // the bubble diameter. We add some margin between elements to
        // balance the vertical spacing.
        tickerSpan = document.createElement('div');
        tickerSpan.textContent = stock.ticker;
        // Font size for ticker is roughly 40% of the diameter but not
        // less than 14px.
        tickerSpan.style.fontSize = Math.max(14, size * 0.40) + 'px';
        tickerSpan.style.lineHeight = '1';
        tickerSpan.style.marginTop = (size * 0.02) + 'px';
        pctSpan = document.createElement('div');
        pctSpan.textContent = pctStr;
        pctSpan.style.fontSize = Math.max(12, size * 0.22) + 'px';
        pctSpan.style.lineHeight = '1';
        pctSpan.style.marginTop = (size * 0.01) + 'px';
      } else {
        // Fallback: generate a bubble with a random size, hue and value.
        size = Math.random() * 120 + 60;
        const randomValue = (Math.random() * 100).toFixed(2);
        const hue = randomHue();
        gradient =
          'radial-gradient(circle at 40% 40%, ' +
          'hsla(' + hue + ', 90%, 70%, 0.8) 0%, ' +
          'hsla(' + hue + ', 90%, 40%, 0.6) 70%, ' +
          'hsla(' + hue + ', 90%, 30%, 0.0) 90%)';
        borderColor = 'hsl(' + hue + ', 80%, 55%)';
        // Single-line content for fallback: just the random value. We use
        // the ticker span to hold it.
        tickerSpan = document.createElement('div');
        tickerSpan.textContent = randomValue;
        tickerSpan.style.fontSize = Math.max(14, size * 0.30) + 'px';
        tickerSpan.style.lineHeight = '1';
      }
      // Generate starting positions and velocities. Randomly position within
      // the viewport bounds taking into account the bubble size.
      const startX = Math.random() * Math.max(0, window.innerWidth - size);
      const startY = Math.random() * Math.max(0, window.innerHeight - size);
      const vx = (Math.random() - 0.5) * 2;
      const vy = (Math.random() - 0.5) * 2;
      // Create the bubble container element. We use flexbox to stack
      // children vertically and centre them. Additional effects such as
      // a thick neon ring and drop shadow are applied via border and
      // box-shadow.
      const div = document.createElement('div');
      div.className = 'bubble';
      div.style.width = size + 'px';
      div.style.height = size + 'px';
      div.style.borderRadius = '50%';
      div.style.display = 'flex';
      div.style.flexDirection = 'column';
      div.style.alignItems = 'center';
      div.style.justifyContent = 'center';
      div.style.cursor = 'grab';
      div.style.userSelect = 'none';
      div.style.pointerEvents = 'auto';
      div.style.color = 'white';
      div.style.fontWeight = 'bold';
      div.style.textAlign = 'center';
      div.style.background = gradient;
      // Set border thickness as 4% of the diameter to form a clear neon ring.
      const borderThickness = size * 0.04;
      div.style.border = borderThickness + 'px solid ' + borderColor;
      // Add a soft glow using box-shadow. The spread radius is a fraction
      // of the diameter to create a halo around the bubble.
      const glowRadius = size * 0.2;
      div.style.boxShadow = '0 0 ' + glowRadius + 'px ' + borderColor;
      // Append icon, ticker and percentage spans if present. Use small
      // margins to space them out. When iconSpan or pctSpan are null
      // they are skipped.
      if (iconSpan) {
        div.appendChild(iconSpan);
      }
      if (tickerSpan) {
        div.appendChild(tickerSpan);
      }
      if (pctSpan) {
        div.appendChild(pctSpan);
      }
      container.appendChild(div);
      return {
        el: div,
        x: startX,
        y: startY,
        vx: vx,
        vy: vy,
        size: size,
        changePercent: changePercent,
        releasedCooldown: 0
      };
    }

    // Populate the bubbles array.
    // In the stock mode we defer populating the bubbles until after
    // fetching data from the server. The `loadStockData` function will
    // build bubbles based on the downloaded data. If fetching fails,
    // this fallback block will be used to populate with random values.
    function populateFallback() {
      for (let i = 0; i < numBubbles; i++) {
        bubbles.push(createBubble());
      }
    }

    /**
     * Fetch the S&P 500 constituents and their realtime prices from our
     * server. The server proxies the Intrinio API and reads the API
     * key from an environment variable so the key remains secret. On
     * success, this will assign `stockData` and update `numBubbles` to
     * the length of the returned array. Then it will create bubbles
     * using each stock entry. If the fetch fails (e.g. due to
     * network/authorization errors), it will fall back to creating
     * random bubbles.
     */
    async function loadStockData() {
      try {
        const response = await fetch('/api/sp500');
        if (!response.ok) {
          throw new Error('Failed to fetch SP500 data');
        }
        const data = await response.json();
        // Use the returned array of {ticker, price} objects.
        stockData = Array.isArray(data) ? data : null;
        if (stockData && stockData.length > 0) {
          numBubbles = stockData.length;
          // Compute the maximum absolute change once so sizes are scaled
          // proportionally. Avoid division by zero by defaulting to 1 if all
          // values are zero or undefined.
          let maxVal = 0;
          for (const s of stockData) {
            const cp = Math.abs(s.changePercent || 0);
            if (cp > maxVal) maxVal = cp;
          }
          maxAbsChange = maxVal > 0 ? maxVal : 1;
          for (let i = 0; i < numBubbles; i++) {
            bubbles.push(createBubble(stockData[i]));
          }
        } else {
          // Fallback to random bubbles if data is empty.
          populateFallback();
        }
      } catch (err) {
        console.error(err);
        // Populate with random bubbles if an error occurs.
        populateFallback();
      }
      // Start the animation once bubbles are created.
      animate();
    }

    // Variables to track dragging state.
    let dragging = false;
    let draggedBubble = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    // Track the current mouse coordinates. These values are updated on every
    // mousemove event so we always know where the pointer is. Without this, using
    // window.event in the animation loop would not work reliably.
    let mouseX = 0;
    let mouseY = 0;

    /**
     * Find the bubble object for a given DOM element.
     * @param {HTMLElement} target
     * @returns {object|null}
     */
    function findBubbleByElement(target) {
      for (const bubble of bubbles) {
        if (bubble.el === target) {
          return bubble;
        }
      }
      return null;
    }

    // Handle mouse down to start dragging.
    container.addEventListener('mousedown', function (e) {
      const target = e.target;
      if (target.classList.contains('bubble')) {
        const bubble = findBubbleByElement(target);
        if (bubble) {
          dragging = true;
          draggedBubble = bubble;
          // Mark the element for cursor change.
          bubble.el.classList.add('dragging');
          // Compute the offset between mouse position and bubble position to
          // maintain where inside the bubble the user clicked.
          const rect = bubble.el.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          // Prevent default to avoid text selection, etc.
          e.preventDefault();
        }
      }
    });

    // Track mouse movement to update the current pointer position. This ensures
    // we always have up‑to‑date coordinates when calculating drag forces. We attach
    // this to the container so movements outside a bubble still update the values.
    container.addEventListener('mousemove', function (e) {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // Handle mouse up to stop dragging.
    window.addEventListener('mouseup', function () {
      if (dragging && draggedBubble) {
        draggedBubble.el.classList.remove('dragging');
        // When dragging ends, zero out the bubble's velocity and start a
        // cooldown period during which jitter is suppressed. This prevents
        // the bubble from wobbling back and forth after being released.
        draggedBubble.vx = 0;
        draggedBubble.vy = 0;
        // Set a cooldown period after dragging ends. During this time the
        // repulsion force on this bubble is reduced and jitter is
        // suppressed. Increase the number of frames to lengthen the
        // settling time. At 60fps, 40 frames ≈ 0.66s.
        draggedBubble.releasedCooldown = 40;
      }
      dragging = false;
      draggedBubble = null;
    });

    // Main animation loop. Applies forces, updates positions and DOM.
    function animate() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      // Apply pairwise repulsion between all bubbles. This runs in O(n²), but
      // with 200 elements it's still performant in modern browsers. The
      // repulsion pushes overlapping or nearby bubbles apart.
      for (let i = 0; i < bubbles.length; i++) {
        const b1 = bubbles[i];
        for (let j = i + 1; j < bubbles.length; j++) {
          const b2 = bubbles[j];
          const dx = b1.x + b1.size / 2 - (b2.x + b2.size / 2);
          const dy = b1.y + b1.size / 2 - (b2.y + b2.size / 2);
          const distSq = dx * dx + dy * dy;
          const minDist = (b1.size + b2.size) / 2;
          // Only apply a force when bubbles are within repulsion range.
          if (distSq < (minDist * minDist)) {
            const dist = Math.sqrt(distSq) || 1;
            // Normalise direction vector.
            const ux = dx / dist;
            const uy = dy / dist;
            // Strength of force increases as bubbles get closer.
            const strength = (minDist - dist) / minDist;
            // Determine if either bubble is currently being dragged. If so,
            // multiply the base repulsion strength so the dragged bubble
            // more effectively clears a path through neighbours. Also
            // reduce the repulsion if one of the bubbles is in its
            // post‑release cooldown period to minimise jitter.
            let forceMultiplier = 1;
            if (draggedBubble && (b1 === draggedBubble || b2 === draggedBubble)) {
              forceMultiplier *= dragRepulsionMultiplier;
            }
            if (b1.releasedCooldown > 0 || b2.releasedCooldown > 0) {
              forceMultiplier *= releasedRepulsionFactor;
            }
            const force = repulsionStrength * strength * forceMultiplier;
            // Push each bubble away from the other.
            b1.vx += ux * force;
            b1.vy += uy * force;
            b2.vx -= ux * force;
            b2.vy -= uy * force;
          }
        }
      }

      bubbles.forEach(function (bubble) {
        // Add some random jitter to create a gentle drifting motion. Jitter
        // is omitted for the bubble being dragged (it follows the mouse) and
        // for a short period after a bubble is released to prevent shaking.
        if (bubble !== draggedBubble && bubble.releasedCooldown === 0) {
          bubble.vx += (Math.random() - 0.5) * jitter;
          bubble.vy += (Math.random() - 0.5) * jitter;
        } else if (bubble.releasedCooldown > 0) {
          // Decrement the cooldown counter each frame. When it reaches zero
          // jitter will resume for this bubble.
          bubble.releasedCooldown--;
        }

            // Previously, negative‑percentage bubbles drifted downward. To
            // simplify the behaviour so all bubbles move consistently, we no
            // longer apply a downward acceleration for losers. The natural
            // random jitter and repulsion will still provide gentle motion.

        // If this bubble is currently being dragged, apply a force that
        // accelerates it towards the mouse position. The offset keeps the
        // pointer relative to where it initially grabbed the bubble. The
        // multiplier controls how quickly the bubble catches up to the
        // pointer—lower values mean more inertia.
        if (dragging && bubble === draggedBubble) {
          // Compute the target position based on the current mouse coordinates minus
          // the offset captured when the bubble was first clicked. This avoids using
          // the deprecated window.event property and works across all browsers.
          const targetX = mouseX - dragOffsetX;
          const targetY = mouseY - dragOffsetY;
          const dx = targetX - bubble.x;
          const dy = targetY - bubble.y;
          // Apply a proportional force towards the target. Lower values result in
          // more inertia; higher values make the bubble follow the pointer more
          // closely.
          // Reduce the follow strength so the bubble lags behind the pointer
          // and chases it, creating an inertia effect. Lower values increase
          // inertia; previously this was 0.2 which made the bubble snap too
          // quickly and oscillate on release.
          // Increase follow strength so the dragged bubble gains enough
          // momentum to push neighbouring bubbles aside while still
          // maintaining some inertia (it will lag slightly behind the pointer).
          // Lower followStrength makes the dragged bubble lag further behind
          // the pointer, increasing inertia. A higher value would make it
          // snap more quickly to the cursor. Here we choose 0.12 to
          // provide a noticeable delay while still allowing the bubble to
          // accelerate enough to push neighbours aside.
          // Strength of the pull towards the mouse while dragging. A
          // smaller value makes the dragged bubble chase the pointer
          // more slowly, increasing inertia. We reduce this from
          // 0.12 to 0.10 to give the bubble a bit more lag, which
          // allows it to build momentum and push through other bubbles
          // without snapping directly under the cursor.
          const followStrength = 0.10;
          bubble.vx += dx * followStrength;
          bubble.vy += dy * followStrength;
        }

        // Apply friction so bubbles eventually slow down.
        bubble.vx *= friction;
        bubble.vy *= friction;

        // Update position based on velocity.
        bubble.x += bubble.vx;
        bubble.y += bubble.vy;

        // Constrain bubbles within viewport boundaries. When a bubble hits
        // the edge, invert its velocity component and clamp its position
        // inside the bounds.
        if (bubble.x < 0) {
          bubble.x = 0;
          bubble.vx *= -1;
        }
        if (bubble.x + bubble.size > width) {
          bubble.x = width - bubble.size;
          bubble.vx *= -1;
        }
        if (bubble.y < 0) {
          bubble.y = 0;
          bubble.vy *= -1;
        }
        if (bubble.y + bubble.size > height) {
          bubble.y = height - bubble.size;
          bubble.vy *= -1;
        }

        // Update DOM element transform. Using translate for better performance.
        bubble.el.style.transform =
          'translate(' + bubble.x + 'px, ' + bubble.y + 'px)';
      });

      requestAnimationFrame(animate);
    }

    // Kick off the data loading process. This will populate the
    // `bubbles` array and start the animation when complete. Without
    // awaiting here, the browser continues to parse and event handlers
    // are attached immediately.
    loadStockData();
  </script>
</body>
</html>
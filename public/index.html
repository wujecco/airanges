<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Buble One</title>
  <style>
    body {
      margin: 0;
      background: #0d0f23;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #bubble-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    .bubble {
      position: absolute;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      text-align: center;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
      /* Allow pointer interaction so bubbles can be dragged */
      pointer-events: auto;
      user-select: none;
      cursor: grab;
    }
    /* Change cursor while actively dragging */
    .bubble.dragging {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <div id="bubble-container"></div>
  <script>
    /**
     * This script implements an interactive bubble field.
     *
     * Key changes from the original version:
     *  - The number of bubbles has been increased from the original but
     *    reduced from the previous version to around 150 for better
     *    readability and performance.
     *  - Bubbles spawn randomly across the screen (rather than in a tight
     *    cluster) and repel each other to settle into an even distribution.
     *  - Pairwise repulsion runs each frame to prevent overlaps and, in
     *    combination with random initial velocities, provides a gentle drift.
     *  - Mouse interaction is rewritten: bubbles no longer flee from the
     *    pointer; instead you can click and drag any bubble. Dragging applies
     *    a proportional force so the bubble chases your pointer with some
     *    inertia. While dragging, the bubble still repels others, pushing
     *    them aside naturally. Releasing a bubble dampens its velocity to
     *    avoid jittery oscillations.
     */

    const container = document.getElementById('bubble-container');
    const bubbles = [];
    const numBubbles = 150;
    // Strength of inter‑bubble repulsion. A modest value causes bubbles
    // to separate gently without an explosive "blow‑apart" effect. This
    // value matches the original implementation.
    const repulsionStrength = 0.07;
    // Friction factor to slow down bubbles over time. Higher friction
    // damps residual velocities after dragging to prevent excessive wobble.
    const friction = 0.98;
    // Amount of random jitter added to each bubble's velocity every frame
    // to simulate gentle drift. Slightly higher than before so bubbles
    // continue to drift when their initial velocities decay.
    const jitter = 0.03;

    /**
     * Generate a random hue for bubble colouring.
     * @returns {number}
     */
    function randomHue() {
      return Math.floor(Math.random() * 360);
    }

    /**
     * Create a bubble DOM element and corresponding state object.
     * Initially position all bubbles near the centre of the viewport with a
     * small random offset so they will push apart under the repulsion force.
     * @returns {{el: HTMLElement, x: number, y: number, vx: number, vy: number, size: number}}
     */
    function createBubble() {
      // Bubble sizes vary between 50 and 170px.
      const size = Math.random() * 120 + 50;
      // Start at a random location within the viewport. Subtract the
      // bubble size so it remains fully visible. This distributes
      // bubbles across the screen rather than clumping them together.
      const startX = Math.random() * (window.innerWidth - size);
      const startY = Math.random() * (window.innerHeight - size);
      // Give each bubble a small random initial velocity so that it drifts
      // naturally. The range is modest (±1), producing a gentle motion.
      const vx = (Math.random() - 0.5) * 2;
      const vy = (Math.random() - 0.5) * 2;
      // Random numeric label for the bubble.
      const value = (Math.random() * 100).toFixed(2);
      // Colour using a radial gradient based on a random hue.
      const hue = randomHue();
      const div = document.createElement('div');
      div.className = 'bubble';
      div.style.width = size + 'px';
      div.style.height = size + 'px';
      div.style.background =
        'radial-gradient(circle at 30% 30%, ' +
        'hsla(' + hue + ', 90%, 70%, 0.8), ' +
        'hsla(' + hue + ', 90%, 50%, 0.6) 70%, transparent)';
      div.textContent = value;
      container.appendChild(div);
      return {
        el: div,
        x: startX,
        y: startY,
        vx: vx,
        vy: vy,
        size: size,
        // When a bubble is released after dragging, this counter is set
        // to a positive value. During the cooldown, jitter is suppressed
        // to avoid shaking while the bubble settles.
        releasedCooldown: 0
      };
    }

    // Populate the bubbles array.
    for (let i = 0; i < numBubbles; i++) {
      bubbles.push(createBubble());
    }

    // Variables to track dragging state.
    let dragging = false;
    let draggedBubble = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    // Track the current mouse coordinates. These values are updated on every
    // mousemove event so we always know where the pointer is. Without this, using
    // window.event in the animation loop would not work reliably.
    let mouseX = 0;
    let mouseY = 0;

    /**
     * Find the bubble object for a given DOM element.
     * @param {HTMLElement} target
     * @returns {object|null}
     */
    function findBubbleByElement(target) {
      for (const bubble of bubbles) {
        if (bubble.el === target) {
          return bubble;
        }
      }
      return null;
    }

    // Handle mouse down to start dragging.
    container.addEventListener('mousedown', function (e) {
      const target = e.target;
      if (target.classList.contains('bubble')) {
        const bubble = findBubbleByElement(target);
        if (bubble) {
          dragging = true;
          draggedBubble = bubble;
          // Mark the element for cursor change.
          bubble.el.classList.add('dragging');
          // Compute the offset between mouse position and bubble position to
          // maintain where inside the bubble the user clicked.
          const rect = bubble.el.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          // Prevent default to avoid text selection, etc.
          e.preventDefault();
        }
      }
    });

    // Track mouse movement to update the current pointer position. This ensures
    // we always have up‑to‑date coordinates when calculating drag forces. We attach
    // this to the container so movements outside a bubble still update the values.
    container.addEventListener('mousemove', function (e) {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // Handle mouse up to stop dragging.
    window.addEventListener('mouseup', function () {
      if (dragging && draggedBubble) {
        draggedBubble.el.classList.remove('dragging');
        // When dragging ends, zero out the bubble's velocity and start a
        // cooldown period during which jitter is suppressed. This prevents
        // the bubble from wobbling back and forth after being released.
        draggedBubble.vx = 0;
        draggedBubble.vy = 0;
        // Set a short cooldown in frames (e.g. 20 frames ≈ 0.33s at 60fps).
        draggedBubble.releasedCooldown = 20;
      }
      dragging = false;
      draggedBubble = null;
    });

    // Main animation loop. Applies forces, updates positions and DOM.
    function animate() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      // Apply pairwise repulsion between all bubbles. This runs in O(n²), but
      // with 200 elements it's still performant in modern browsers. The
      // repulsion pushes overlapping or nearby bubbles apart.
      for (let i = 0; i < bubbles.length; i++) {
        const b1 = bubbles[i];
        for (let j = i + 1; j < bubbles.length; j++) {
          const b2 = bubbles[j];
          const dx = b1.x + b1.size / 2 - (b2.x + b2.size / 2);
          const dy = b1.y + b1.size / 2 - (b2.y + b2.size / 2);
          const distSq = dx * dx + dy * dy;
          const minDist = (b1.size + b2.size) / 2;
          // Only apply a force when bubbles are within repulsion range.
          if (distSq < (minDist * minDist)) {
            const dist = Math.sqrt(distSq) || 1;
            // Normalise direction vector.
            const ux = dx / dist;
            const uy = dy / dist;
            // Strength of force increases as bubbles get closer.
            const strength = (minDist - dist) / minDist;
            const force = repulsionStrength * strength;
            // Push each bubble away from the other.
            b1.vx += ux * force;
            b1.vy += uy * force;
            b2.vx -= ux * force;
            b2.vy -= uy * force;
          }
        }
      }

      bubbles.forEach(function (bubble) {
        // Add some random jitter to create a gentle drifting motion. Jitter
        // is omitted for the bubble being dragged (it follows the mouse) and
        // for a short period after a bubble is released to prevent shaking.
        if (bubble !== draggedBubble && bubble.releasedCooldown === 0) {
          bubble.vx += (Math.random() - 0.5) * jitter;
          bubble.vy += (Math.random() - 0.5) * jitter;
        } else if (bubble.releasedCooldown > 0) {
          // Decrement the cooldown counter each frame. When it reaches zero
          // jitter will resume for this bubble.
          bubble.releasedCooldown--;
        }

        // If this bubble is currently being dragged, apply a force that
        // accelerates it towards the mouse position. The offset keeps the
        // pointer relative to where it initially grabbed the bubble. The
        // multiplier controls how quickly the bubble catches up to the
        // pointer—lower values mean more inertia.
        if (dragging && bubble === draggedBubble) {
          // Compute the target position based on the current mouse coordinates minus
          // the offset captured when the bubble was first clicked. This avoids using
          // the deprecated window.event property and works across all browsers.
          const targetX = mouseX - dragOffsetX;
          const targetY = mouseY - dragOffsetY;
          const dx = targetX - bubble.x;
          const dy = targetY - bubble.y;
          // Apply a proportional force towards the target. Lower values result in
          // more inertia; higher values make the bubble follow the pointer more
          // closely.
          // Reduce the follow strength so the bubble lags behind the pointer
          // and chases it, creating an inertia effect. Lower values increase
          // inertia; previously this was 0.2 which made the bubble snap too
          // quickly and oscillate on release.
          // Increase follow strength so the dragged bubble gains enough
          // momentum to push neighbouring bubbles aside while still
          // maintaining some inertia (it will lag slightly behind the pointer).
          const followStrength = 0.15;
          bubble.vx += dx * followStrength;
          bubble.vy += dy * followStrength;
        }

        // Apply friction so bubbles eventually slow down.
        bubble.vx *= friction;
        bubble.vy *= friction;

        // Update position based on velocity.
        bubble.x += bubble.vx;
        bubble.y += bubble.vy;

        // Constrain bubbles within viewport boundaries. When a bubble hits
        // the edge, invert its velocity component and clamp its position
        // inside the bounds.
        if (bubble.x < 0) {
          bubble.x = 0;
          bubble.vx *= -1;
        }
        if (bubble.x + bubble.size > width) {
          bubble.x = width - bubble.size;
          bubble.vx *= -1;
        }
        if (bubble.y < 0) {
          bubble.y = 0;
          bubble.vy *= -1;
        }
        if (bubble.y + bubble.size > height) {
          bubble.y = height - bubble.size;
          bubble.vy *= -1;
        }

        // Update DOM element transform. Using translate for better performance.
        bubble.el.style.transform =
          'translate(' + bubble.x + 'px, ' + bubble.y + 'px)';
      });

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>